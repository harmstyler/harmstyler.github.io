<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: eZ Find | HarmsSite]]></title>
  <link href="http://harmstyler.github.io/blog/categories/ez-find/atom.xml" rel="self"/>
  <link href="http://harmstyler.github.io/"/>
  <updated>2013-04-14T07:15:15-05:00</updated>
  <id>http://harmstyler.github.io/</id>
  <author>
    <name><![CDATA[Tyler Harms]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optimizing Solr To Fit Your Needs Part 2]]></title>
    <link href="http://harmstyler.github.io/blog/2012/12/07/optimizing-solr-to-fit-your-needs-part-2/"/>
    <updated>2012-12-07T00:00:00-06:00</updated>
    <id>http://harmstyler.github.io/blog/2012/12/07/optimizing-solr-to-fit-your-needs-part-2</id>
    <content type="html"><![CDATA[<p>I am finally taking the time to write about optimizing the Solr schema file. In my last post I showed that eZ Find already ships with a default search field called <code>ezf_df_text</code>. The downside of searching one field is that field needs to be controlled, and the only way it can be controlled is by manually editing the Solr schema file. As you might expect, eZ Find does not control this file very well out of the box.
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>schema.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;copyField</span> <span class="na">source=</span><span class="s">&quot;*_lk&quot;</span> <span class="na">dest=</span><span class="s">&quot;ezf_df_text&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;copyField</span> <span class="na">source=</span><span class="s">&quot;*_k&quot;</span> <span class="na">dest=</span><span class="s">&quot;ezf_df_text&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;copyField</span> <span class="na">source=</span><span class="s">&quot;*_t&quot;</span> <span class="na">dest=</span><span class="s">&quot;ezf_df_text&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;copyField</span> <span class="na">source=</span><span class="s">&quot;*_s&quot;</span> <span class="na">dest=</span><span class="s">&quot;ezf_df_text&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
A copyField will take any field you tell it to and <em>copy it</em> into another field. The code above is what ships with eZ Find, every single <code>*_lk</code> (lckeyword), <code>*_k</code> (keyword), <code>*_t</code> (text), and <code>*_s</code> (string) is added to the <code>ezf_df_text</code> field. For obvious reasons the average installation probably doesn't need every piece of content searchable. The first step is to <strong>delete the default copyFields</strong> (e.g. your site users probably shouldn't be searched by default).</p>

<!--more-->


<p>Luckily, there is only one other step! Unfortunately, this one step can be very time consuming. Visit the <code>luke</code> output for your Solr install and make a list of all the fields you need to search. Make a copyField for every field you want to search, adding each field to the <code>ezf_df_text</code> field.</p>

<p>Remember, this can offer major speed improvements in your searches, especially if you are managing a large amount of content. There are still other optimizations (stored/not stored, indexed/not indexed, term vectors, etc), but that is for another time.</p>

<p>Finally, I did submit a pull request to the eZ Find project. It adds a new search parameter allowing users to declare custom search fields.
<a href="http://bit.ly/Vp98IU">https://github.com/ezsystems/ezfind/pull/93</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing Solr to fit your needs Part 1]]></title>
    <link href="http://harmstyler.github.io/blog/2012/08/25/optimizing-solr-to-fit-your-needs-part-1/"/>
    <updated>2012-08-25T00:00:00-05:00</updated>
    <id>http://harmstyler.github.io/blog/2012/08/25/optimizing-solr-to-fit-your-needs-part-1</id>
    <content type="html"><![CDATA[<div class="pull-right"><img class="zemanta-img-inserted zemanta-img-configured" title="Solr logo" src="http://upload.wikimedia.org/wikipedia/en/3/3e/Solr.png" alt="Solr logo" width="283" height="156" /></div>


<p>Let me start by saying that eZ Find is a fantastic implementation of <a class="zem_slink" title="Apache Solr" href="http://lucene.apache.org/solr/" rel="homepage" target="_blank">Solr</a> functionality. With eZ Find you get a fantastic search, out of the box. eZ Find gathers all the content in your system and organizes it for you into strings, text, and keywords (there are more but those the types I use most often). It can look at an <a class="zem_slink" title="EZ Publish" href="http://ez.no/" rel="homepage" target="_blank">eZ Publish</a> keyword and know that it should thereby be a Solr keyword, again, all out of the box. There are however some serious limitations when it comes time to customize it to meet your system's needs. Do not underestimate the power found in customizing Solr to meet your website's needs. The default setup is great, it's made to fit into any system with very little effort; but, just because it's made to fit in any system does not mean that it should be used for every system.</p>

<p>One of the best things we could have ever done for a large Solr install was to customize a default search field. You might say, "But eZ Find already creates a default search field for you." And you'd be right.
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;!-- field for the QueryParser to use when an explicit fieldname is absent --&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;defaultSearchField&gt;</span>ezf_df_text<span class="nt">&lt;/defaultSearchField&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The thing that the default search field in eZ Find does not do, however, is get used. There is no way in eZ Find to tell it to search just one field (at least as far as I know). I did some testing in our environment, these numbers will change from system to system, but in our's each search took almost 10 times as long to search all fields individually vs searching just 1 field. We gave eZ Find the option to search one given field, if defined, and it vastly improved our search experience.</p>

<p>eZ Find by default looks at all 'searchable' fields and adds them to either the <a title="qf" href="http://wiki.apache.org/solr/DisMaxQParserPlugin#qf_.28Query_Fields.29"><code>qf</code></a> (if you are using the dismax search like you should be) or it searches every searchable field individually (<code>attr_title_t:(*:*)</code>, <code>attr_title_s:(*:*)</code>, etc, etc, for all searchable fields). All the 'searchable' fields are by default added to the <code>ezf_df_text</code> field, so you should really do yourself a favor and search just one field, it is a noticable speed improvement, especially in large systems.</p>

<p>In Part 2 I will talk about how to better optimize the Solr <code>schema.xml</code> file using the <code>ezf_df_text</code> field.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixing Shards in eZ Find]]></title>
    <link href="http://harmstyler.github.io/blog/2012/06/29/fixing-shards-in-ez-find/"/>
    <updated>2012-06-29T00:00:00-05:00</updated>
    <id>http://harmstyler.github.io/blog/2012/06/29/fixing-shards-in-ez-find</id>
    <content type="html"><![CDATA[<p>I am way overdue on my promise to show you how to make shards work. As I said before, shards in eZ Find do not work out of the box. In the code the <code>$shardQuery</code> is built properly but the variable is never actually used after it is created. What I did to make this work is a simple if/else block inside the <code>$queryHandler</code> switch. I am not submitting this as a pull request to eZ Find at the moment just because I do not like the way I made this work, I feel like there is a better way to do it. Nevertheless here is my code to make Shards work, I hope you enjoy and moreover I hope you suggest a better way to make the code work ;)</p>

<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>ezfezpsolrquerybuilder.php </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">&amp;lt;?php</span>
</span><span class='line'><span class="x">switch ( $queryHandler )</span>
</span><span class='line'><span class="x">{&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="x">&lt;pre&gt;&lt;code&gt;case &#39;standard&#39;:</span>
</span><span class='line'><span class="x">    // @todo: this is more complicated</span>
</span><span class='line'><span class="x">    // build the query against all &quot;text&quot; like fields</span>
</span><span class='line'><span class="x">    // should take into account all the filter fields and class filters to shorten the query</span>
</span><span class='line'><span class="x">    // need to build: Solr q</span>
</span><span class='line'><span class="x">    if ( array_key_exists( &#39;fields&#39;, $boostFunctions ) )</span>
</span><span class='line'><span class="x">    {</span>
</span><span class='line'><span class="x">        if (false != $shardQuery) {</span>
</span><span class='line'><span class="x">        $handlerParameters = array ( &#39;q&#39; =&amp;gt; $this-&amp;gt;buildMultiFieldQuery( $searchText, array_merge( $queryFields, $extraFieldsToSearch ), $boostFunctions[&#39;fields&#39;] ),</span>
</span><span class='line'><span class="x">                                 &#39;qt&#39; =&amp;gt; &#39;standard&#39;,</span>
</span><span class='line'><span class="x">                                 &#39;shards&#39; =&amp;gt; $shardQuery);</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'><span class="x">        else {</span>
</span><span class='line'><span class="x">        $handlerParameters = array ( &#39;q&#39; =&amp;gt; $this-&amp;gt;buildMultiFieldQuery( $searchText, array_merge( $queryFields, $extraFieldsToSearch ), $boostFunctions[&#39;fields&#39;] ),</span>
</span><span class='line'><span class="x">                                 &#39;qt&#39; =&amp;gt; &#39;standard&#39;, );</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">    else</span>
</span><span class='line'><span class="x">    {</span>
</span><span class='line'><span class="x">        if (false != $shardQuery) {</span>
</span><span class='line'><span class="x">        $handlerParameters = array ( &#39;q&#39; =&amp;gt; $this-&amp;gt;buildMultiFieldQuery( $searchText, array_merge( $queryFields, $extraFieldsToSearch ) ),</span>
</span><span class='line'><span class="x">                                 &#39;qt&#39; =&amp;gt; &#39;standard&#39;,</span>
</span><span class='line'><span class="x">                                 &#39;shards&#39; =&amp;gt; $shardQuery);</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'><span class="x">        else{</span>
</span><span class='line'><span class="x">            $handlerParameters = array ( &#39;q&#39; =&amp;gt; $this-&amp;gt;buildMultiFieldQuery( $searchText, array_merge( $queryFields, $extraFieldsToSearch ) ),</span>
</span><span class='line'><span class="x">                                 &#39;qt&#39; =&amp;gt; &#39;standard&#39; );</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">    break;</span>
</span><span class='line'>
</span><span class='line'><span class="x">case &#39;simplestandard&#39;:</span>
</span><span class='line'><span class="x">    // not to do much, searching is against the default aggregated field</span>
</span><span class='line'><span class="x">    // only highlightfields</span>
</span><span class='line'><span class="x">    $highLightFields = array ( &#39;ezf_df_text&#39; );</span>
</span><span class='line'><span class="x">    $handlerParameters = array ( &#39;q&#39; =&amp;gt; $searchText,</span>
</span><span class='line'><span class="x">                                 &#39;qt&#39; =&amp;gt; &#39;standard&#39;,</span>
</span><span class='line'><span class="x">                                 &#39;hl.usePhraseHighlighter&#39; =&amp;gt; &#39;true&#39;,</span>
</span><span class='line'><span class="x">                                 &#39;hl.highlightMultiTerm&#39; =&amp;gt; &#39;true&#39; );</span>
</span><span class='line'><span class="x">    break;</span>
</span><span class='line'><span class="x">case &#39;ezpublish&#39;:</span>
</span><span class='line'><span class="x">    // the dismax based handler, just keywordss input, most useful for ordinary queries by users</span>
</span><span class='line'><span class="x">    // need to build: Solr q, qf, dismax specific parameters</span>
</span><span class='line'>
</span><span class='line'><span class="x">default:</span>
</span><span class='line'><span class="x">    // ezpublish of course, this to not break BC and is the most &quot;general&quot;</span>
</span><span class='line'><span class="x">    // if another value is specified, it is supposed to be a dismax like handler</span>
</span><span class='line'><span class="x">    // with possible other tuning variables then the stock provided &#39;ezpublish&#39; in solrconfi.xml</span>
</span><span class='line'><span class="x">    // remark it should be lowercase in solrconfig.xml!</span>
</span><span class='line'><span class="x">    if (false != $shardQuery) {</span>
</span><span class='line'><span class="x">        $handlerParameters = array ( &#39;q&#39; =&amp;gt; $searchText,</span>
</span><span class='line'><span class="x">                                     &#39;qf&#39; =&amp;gt; implode( &#39; &#39;, array_merge( $queryFields, $extraFieldsToSearch ) ),</span>
</span><span class='line'><span class="x">                                     &#39;qt&#39; =&amp;gt; $queryHandler,</span>
</span><span class='line'><span class="x">                                     &#39;shards&#39; =&amp;gt; $shardQuery );</span>
</span><span class='line'><span class="x">    } else {</span>
</span><span class='line'><span class="x">        $handlerParameters = array ( &#39;q&#39; =&amp;gt; $searchText,</span>
</span><span class='line'><span class="x">                                     &#39;qf&#39; =&amp;gt; implode( &#39; &#39;, array_merge( $queryFields, $extraFieldsToSearch ) ),</span>
</span><span class='line'><span class="x">                                     &#39;qt&#39; =&amp;gt; $queryHandler );</span>
</span><span class='line'>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="x">&lt;p&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solr 3.6 Update]]></title>
    <link href="http://harmstyler.github.io/blog/2012/05/14/solr-3-6-update/"/>
    <updated>2012-05-14T00:00:00-05:00</updated>
    <id>http://harmstyler.github.io/blog/2012/05/14/solr-3-6-update</id>
    <content type="html"><![CDATA[<p>Turns out that when using shards to search multiple cores (shards in general actually) binary is not returned properly. I found an update to the trunk (4.x) version of Solr and was successfully able to update my version of Solr 3.6. I am submitting a pull request of the code update to Solr as well a new war file to eZ Find, but in the meantime you can download the solr.war file on GitHub (it is in <a href="https://github.com/harmstyler/ezfind" title="harmstyler eZ Find fork">my eZ Find branch</a>). Enjoy!</p>
]]></content>
  </entry>
  
</feed>
